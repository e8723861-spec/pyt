#!/usr/bin/env python3.12
"""
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
MULTI-DEX ARBITRAGE TRADING BOT - SINGLE FILE SOLUTION
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
Features:
- Multi-leg arbitrage across 5+ DEXs (Uniswap V2/V3, Sushiswap, PancakeSwap, etc.)
- No flash loans required (trades with your capital)
- Starts with as little as $5
- Auto-trades multiple crypto pairs
- Profits auto-sent to your MetaMask wallet
- No .env file needed (interactive setup)
- Complete single-file solution

Requirements:
    pip install web3 requests python-dotenv colorama

Usage:
    python3.12 arbitrage_bot_complete.py

Author: AI Assistant
License: MIT
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

import json
import time
import asyncio
import sys
from decimal import Decimal, getcontext
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass, field
from datetime import datetime
import logging

# Set decimal precision for financial calculations
getcontext().prec = 28

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DEPENDENCIES CHECK
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def check_dependencies():
    """Check if all required packages are installed"""
    required = {
        'web3': 'Web3',
        'requests': 'requests',
        'colorama': 'colorama'
    }
    
    missing = []
    for module, package in required.items():
        try:
            __import__(module)
        except ImportError:
            missing.append(package)
    
    if missing:
        print(f"âŒ Missing dependencies: {', '.join(missing)}")
        print(f"\nğŸ“¦ Install with: pip install {' '.join(missing)}")
        sys.exit(1)

check_dependencies()

from web3 import Web3
from web3.middleware import geth_poa_middleware
from eth_account import Account
import requests
from colorama import init, Fore, Style

init(autoreset=True)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# CONFIGURATION & CONSTANTS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Supported chains and their configurations
CHAINS = {
    "1": {
        "name": "Ethereum Mainnet",
        "rpc": "https://eth.llamarpc.com",
        "chain_id": 1,
        "native": "ETH",
        "weth": "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
        "usdc": "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
        "usdt": "0xdAC17F958D2ee523a2206206994597C13D831ec7",
        "dai": "0x6B175474E89094C44Da98b954EedeAC495271d0F",
        "min_trade_usd": 5,
        "gas_price_gwei": 30
    },
    "56": {
        "name": "BSC Mainnet",
        "rpc": "https://bsc-dataseed.binance.org",
        "chain_id": 56,
        "native": "BNB",
        "weth": "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",  # WBNB
        "usdc": "0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d",
        "usdt": "0x55d398326f99059fF775485246999027B3197955",
        "dai": "0x1AF3F329e8BE154074D8769D1FFa4eE058B1DBc3",
        "min_trade_usd": 5,
        "gas_price_gwei": 5
    },
    "137": {
        "name": "Polygon Mainnet",
        "rpc": "https://polygon-rpc.com",
        "chain_id": 137,
        "native": "MATIC",
        "weth": "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",  # WMATIC
        "usdc": "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
        "usdt": "0xc2132D05D31c914a87C6611C10748AEb04B58e8F",
        "dai": "0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063",
        "min_trade_usd": 5,
        "gas_price_gwei": 30
    },
    "42161": {
        "name": "Arbitrum One",
        "rpc": "https://arb1.arbitrum.io/rpc",
        "chain_id": 42161,
        "native": "ETH",
        "weth": "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1",
        "usdc": "0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8",
        "usdt": "0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9",
        "dai": "0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1",
        "min_trade_usd": 5,
        "gas_price_gwei": 0.1
    },
    "10": {
        "name": "Optimism",
        "rpc": "https://mainnet.optimism.io",
        "chain_id": 10,
        "native": "ETH",
        "weth": "0x4200000000000000000000000000000000000006",
        "usdc": "0x7F5c764cBc14f9669B88837ca1490cCa17c31607",
        "usdt": "0x94b008aA00579c1307B0EF2c499aD98a8ce58e58",
        "dai": "0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1",
        "min_trade_usd": 5,
        "gas_price_gwei": 0.001
    }
}

# DEX configurations (Uniswap V2 compatible)
DEXS = {
    "uniswap_v2": {
        "1": "0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D",
        "factory": "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f"
    },
    "sushiswap": {
        "1": "0xd9e1cE17f2641f24aE83637ab66a2cca9C378B9F",
        "137": "0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506",
        "42161": "0x1b02dA8Cb0d097eB8D57A175b88c7D8b47997506",
        "factory": "0xC0AEe478e3658e2610c5F7A4A2E1777cE9e4f2Ac"
    },
    "pancakeswap": {
        "56": "0x10ED43C718714eb63d5aA57B78B54704E256024E",
        "factory": "0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73"
    },
    "quickswap": {
        "137": "0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff",
        "factory": "0x5757371414417b8C6CAad45bAeF941aBc7d3Ab32"
    },
    "camelot": {
        "42161": "0xc873fEcbd354f5A56E00E710B90EF4201db2448d",
        "factory": "0x6EcCab422D763aC031210895C81787E87B43A652"
    },
    "velodrome": {
        "10": "0x9c12939390052919aF3155f41Bf4160Fd3666A6f",
        "factory": "0x25CbdDb98b35ab1FF77413456B31EC81A6B6B746"
    }
}

# ERC20 ABI (minimal)
ERC20_ABI = [
    {"constant": True, "inputs": [{"name": "_owner", "type": "address"}], 
     "name": "balanceOf", "outputs": [{"name": "balance", "type": "uint256"}], "type": "function"},
    {"constant": True, "inputs": [], "name": "decimals", 
     "outputs": [{"name": "", "type": "uint8"}], "type": "function"},
    {"constant": True, "inputs": [], "name": "symbol", 
     "outputs": [{"name": "", "type": "string"}], "type": "function"},
    {"constant": False, "inputs": [{"name": "_spender", "type": "address"}, {"name": "_value", "type": "uint256"}], 
     "name": "approve", "outputs": [{"name": "", "type": "bool"}], "type": "function"},
    {"constant": True, "inputs": [{"name": "_owner", "type": "address"}, {"name": "_spender", "type": "address"}], 
     "name": "allowance", "outputs": [{"name": "", "type": "uint256"}], "type": "function"}
]

# Uniswap V2 Router ABI (minimal)
ROUTER_ABI = [
    {"constant": True, "inputs": [{"name": "amountIn", "type": "uint256"}, {"name": "path", "type": "address[]"}], 
     "name": "getAmountsOut", "outputs": [{"name": "amounts", "type": "uint256[]"}], "type": "function"},
    {"constant": False, "inputs": [
        {"name": "amountIn", "type": "uint256"},
        {"name": "amountOutMin", "type": "uint256"},
        {"name": "path", "type": "address[]"},
        {"name": "to", "type": "address"},
        {"name": "deadline", "type": "uint256"}
    ], "name": "swapExactTokensForTokens", 
     "outputs": [{"name": "amounts", "type": "uint256[]"}], "type": "function"},
    {"constant": False, "inputs": [
        {"name": "amountOutMin", "type": "uint256"},
        {"name": "path", "type": "address[]"},
        {"name": "to", "type": "address"},
        {"name": "deadline", "type": "uint256"}
    ], "name": "swapExactETHForTokens", 
     "outputs": [{"name": "amounts", "type": "uint256[]"}], "type": "function", "payable": True}
]

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# DATA CLASSES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class Token:
    """Token information"""
    address: str
    symbol: str
    decimals: int
    chain_id: int

@dataclass
class PriceQuote:
    """Price quote from a DEX"""
    dex_name: str
    token_in: str
    token_out: str
    amount_in: Decimal
    amount_out: Decimal
    price: Decimal
    gas_estimate: int = 150000

@dataclass
class ArbitrageRoute:
    """Multi-leg arbitrage route"""
    id: str
    legs: List[PriceQuote]
    input_amount: Decimal
    expected_output: Decimal
    profit: Decimal
    profit_pct: Decimal
    gas_cost: Decimal
    net_profit: Decimal
    timestamp: float = field(default_factory=time.time)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# LOGGING SETUP
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('arbitrage_bot.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# HELPER FUNCTIONS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def print_banner():
    """Print colorful banner"""
    banner = f"""
{Fore.CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                                                               â•‘
â•‘   {Fore.YELLOW}ğŸš€ MULTI-DEX ARBITRAGE BOT{Fore.CYAN}                                   â•‘
â•‘                                                               â•‘
â•‘   {Fore.GREEN}âœ“ 5+ DEXs Support{Fore.CYAN}        {Fore.GREEN}âœ“ Multi-leg Arbitrage{Fore.CYAN}          â•‘
â•‘   {Fore.GREEN}âœ“ Start with $5{Fore.CYAN}          {Fore.GREEN}âœ“ Auto-trade Enabled{Fore.CYAN}            â•‘
â•‘   {Fore.GREEN}âœ“ No Flash Loans{Fore.CYAN}         {Fore.GREEN}âœ“ Multiple Chains{Fore.CYAN}               â•‘
â•‘                                                               â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•{Style.RESET_ALL}
"""
    print(banner)

def get_user_input(prompt: str, default: str = None) -> str:
    """Get user input with optional default"""
    if default:
        prompt = f"{prompt} [{default}]: "
    else:
        prompt = f"{prompt}: "
    
    value = input(prompt).strip()
    return value if value else default

def confirm_action(message: str) -> bool:
    """Ask user for confirmation"""
    response = input(f"{message} (yes/no): ").strip().lower()
    return response in ['yes', 'y']

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN BOT CLASS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class MultiDEXArbitrageBot:
    """
    Multi-DEX Arbitrage Trading Bot
    
    Finds and executes profitable arbitrage opportunities across multiple
    decentralized exchanges without using flash loans.
    """
    
    def __init__(self):
        self.w3 = None
        self.account = None
        self.chain_config = None
        self.min_profit_usd = Decimal("0.5")  # Minimum profit threshold
        self.max_trade_amount = None
        self.slippage = Decimal("0.01")  # 1% slippage tolerance
        self.profit_wallet = None
        self.active_dexs = []
        self.stats = {
            "scans": 0,
            "opportunities_found": 0,
            "trades_executed": 0,
            "successful_trades": 0,
            "total_profit_usd": Decimal("0")
        }
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # INITIALIZATION
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def setup(self):
        """Interactive setup wizard"""
        print_banner()
        print(f"\n{Fore.CYAN}{'='*60}")
        print(f"{Fore.YELLOW}SETUP WIZARD")
        print(f"{Fore.CYAN}{'='*60}{Style.RESET_ALL}\n")
        
        # Select chain
        print(f"{Fore.GREEN}Available Chains:{Style.RESET_ALL}")
        for chain_id, config in CHAINS.items():
            print(f"  {chain_id}. {config['name']}")
        
        chain_id = get_user_input("\nSelect chain", "1")
        if chain_id not in CHAINS:
            print(f"{Fore.RED}Invalid chain selection{Style.RESET_ALL}")
            sys.exit(1)
        
        self.chain_config = CHAINS[chain_id]
        print(f"{Fore.GREEN}âœ“ Selected: {self.chain_config['name']}{Style.RESET_ALL}")
        
        # Connect to RPC
        print(f"\n{Fore.CYAN}Connecting to blockchain...{Style.RESET_ALL}")
        self.w3 = Web3(Web3.HTTPProvider(self.chain_config['rpc']))
        
        # Add PoA middleware for BSC, Polygon
        if int(chain_id) in [56, 137]:
            self.w3.middleware_onion.inject(geth_poa_middleware, layer=0)
        
        if not self.w3.is_connected():
            print(f"{Fore.RED}âŒ Failed to connect to {self.chain_config['name']}{Style.RESET_ALL}")
            sys.exit(1)
        
        print(f"{Fore.GREEN}âœ“ Connected to {self.chain_config['name']}{Style.RESET_ALL}")
        print(f"  Block: {self.w3.eth.block_number}")
        
        # Setup wallet
        print(f"\n{Fore.YELLOW}WALLET SETUP{Style.RESET_ALL}")
        print("Choose option:")
        print("  1. Enter private key")
        print("  2. Generate new wallet")
        
        choice = get_user_input("Selection", "1")
        
        if choice == "2":
            # Generate new wallet
            self.account = Account.create()
            print(f"\n{Fore.GREEN}âœ“ New wallet generated:{Style.RESET_ALL}")
            print(f"  Address: {self.account.address}")
            print(f"  {Fore.RED}Private Key: {self.account.key.hex()}{Style.RESET_ALL}")
            print(f"\n{Fore.YELLOW}âš ï¸  SAVE THIS PRIVATE KEY SECURELY!{Style.RESET_ALL}")
            print(f"  Send some {self.chain_config['native']} to this address to start trading.")
            input("\nPress Enter when funded...")
        else:
            # Import existing wallet
            private_key = get_user_input("\nEnter private key (0x...)")
            
            if not private_key.startswith('0x'):
                private_key = '0x' + private_key
            
            try:
                self.account = Account.from_key(private_key)
                print(f"{Fore.GREEN}âœ“ Wallet imported: {self.account.address}{Style.RESET_ALL}")
            except Exception as e:
                print(f"{Fore.RED}âŒ Invalid private key: {e}{Style.RESET_ALL}")
                sys.exit(1)
        
        # Check balance
        balance = self.w3.eth.get_balance(self.account.address)
        balance_eth = Decimal(str(self.w3.from_wei(balance, 'ether')))
        print(f"  Balance: {balance_eth} {self.chain_config['native']}")
        
        if balance_eth < Decimal("0.01"):
            print(f"{Fore.YELLOW}âš ï¸  Low balance. Recommend at least 0.01 {self.chain_config['native']} for gas{Style.RESET_ALL}")
        
        # Setup profit wallet
        use_same = confirm_action(f"\nSend profits to same wallet ({self.account.address})?")
        if use_same:
            self.profit_wallet = self.account.address
        else:
            profit_addr = get_user_input("Enter MetaMask address for profits")
            if self.w3.is_address(profit_addr):
                self.profit_wallet = Web3.to_checksum_address(profit_addr)
                print(f"{Fore.GREEN}âœ“ Profit wallet: {self.profit_wallet}{Style.RESET_ALL}")
            else:
                print(f"{Fore.RED}Invalid address, using trading wallet{Style.RESET_ALL}")
                self.profit_wallet = self.account.address
        
        # Trading parameters
        print(f"\n{Fore.YELLOW}TRADING PARAMETERS{Style.RESET_ALL}")
        
        min_trade = get_user_input(f"Minimum trade amount (USD)", "5")
        self.min_profit_usd = Decimal(min_trade) * Decimal("0.1")  # 10% minimum profit
        
        max_trade = get_user_input(f"Maximum trade amount (USD)", "50")
        self.max_trade_amount = Decimal(max_trade)
        
        slippage = get_user_input("Slippage tolerance (%)", "1")
        self.slippage = Decimal(slippage) / Decimal("100")
        
        # Select DEXs
        print(f"\n{Fore.GREEN}Available DEXs on {self.chain_config['name']}:{Style.RESET_ALL}")
        available_dexs = []
        for dex_name, addresses in DEXS.items():
            if chain_id in addresses:
                available_dexs.append(dex_name)
                print(f"  âœ“ {dex_name}")
        
        if len(available_dexs) < 2:
            print(f"{Fore.RED}Not enough DEXs on this chain for arbitrage{Style.RESET_ALL}")
            sys.exit(1)
        
        self.active_dexs = available_dexs
        print(f"\n{Fore.GREEN}âœ“ Will monitor {len(self.active_dexs)} DEXs{Style.RESET_ALL}")
        
        # Final confirmation
        print(f"\n{Fore.CYAN}{'='*60}")
        print(f"{Fore.YELLOW}CONFIGURATION SUMMARY")
        print(f"{Fore.CYAN}{'='*60}{Style.RESET_ALL}")
        print(f"  Chain: {self.chain_config['name']}")
        print(f"  Trading Wallet: {self.account.address}")
        print(f"  Profit Wallet: {self.profit_wallet}")
        print(f"  Min Trade: ${self.min_profit_usd}")
        print(f"  Max Trade: ${self.max_trade_amount}")
        print(f"  DEXs: {', '.join(self.active_dexs)}")
        print(f"{Fore.CYAN}{'='*60}{Style.RESET_ALL}\n")
        
        if not confirm_action("Start trading?"):
            print("Setup cancelled.")
            sys.exit(0)
        
        print(f"\n{Fore.GREEN}ğŸš€ Starting bot...{Style.RESET_ALL}\n")
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # TOKEN OPERATIONS
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def get_token_info(self, token_address: str) -> Token:
        """Get token information"""
        token_address = Web3.to_checksum_address(token_address)
        contract = self.w3.eth.contract(address=token_address, abi=ERC20_ABI)
        
        try:
            symbol = contract.functions.symbol().call()
            decimals = contract.functions.decimals().call()
            return Token(token_address, symbol, decimals, self.chain_config['chain_id'])
        except Exception as e:
            logger.error(f"Failed to get token info for {token_address}: {e}")
            return None
    
    def get_token_balance(self, token_address: str) -> Decimal:
        """Get token balance"""
        token_address = Web3.to_checksum_address(token_address)
        contract = self.w3.eth.contract(address=token_address, abi=ERC20_ABI)
        
        try:
            balance = contract.functions.balanceOf(self.account.address).call()
            decimals = contract.functions.decimals().call()
            return Decimal(balance) / Decimal(10 ** decimals)
        except Exception as e:
            logger.error(f"Failed to get balance: {e}")
            return Decimal("0")
    
    def approve_token(self, token_address: str, spender: str, amount: int) -> bool:
        """Approve token spending"""
        token_address = Web3.to_checksum_address(token_address)
        spender = Web3.to_checksum_address(spender)
        contract = self.w3.eth.contract(address=token_address, abi=ERC20_ABI)
        
        try:
            # Check current allowance
            allowance = contract.functions.allowance(
                self.account.address, spender
            ).call()
            
            if allowance >= amount:
                return True
            
            # Build approval transaction
            txn = contract.functions.approve(spender, amount).build_transaction({
                'from': self.account.address,
                'nonce': self.w3.eth.get_transaction_count(self.account.address),
                'gas': 100000,
                'gasPrice': self.w3.eth.gas_price
            })
            
            # Sign and send
            signed = self.account.sign_transaction(txn)
            tx_hash = self.w3.eth.send_raw_transaction(signed.raw_transaction)
            
            logger.info(f"Approval sent: {tx_hash.hex()}")
            
            # Wait for confirmation
            receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash, timeout=120)
            
            if receipt['status'] == 1:
                logger.info("Approval confirmed")
                return True
            else:
                logger.error("Approval failed")
                return False
                
        except Exception as e:
            logger.error(f"Approval error: {e}")
            return False
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # PRICE QUERIES
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def get_price_quote(
        self,
        dex_name: str,
        token_in: str,
        token_out: str,
        amount_in: Decimal
    ) -> Optional[PriceQuote]:
        """Get price quote from a DEX"""
        chain_id = str(self.chain_config['chain_id'])
        
        if dex_name not in DEXS or chain_id not in DEXS[dex_name]:
            return None
        
        router_address = DEXS[dex_name][chain_id]
        router = self.w3.eth.contract(
            address=Web3.to_checksum_address(router_address),
            abi=ROUTER_ABI
        )
        
        try:
            # Get token decimals
            token_in_contract = self.w3.eth.contract(
                address=Web3.to_checksum_address(token_in),
                abi=ERC20_ABI
            )
            decimals = token_in_contract.functions.decimals().call()
            
            amount_in_wei = int(amount_in * Decimal(10 ** decimals))
            
            # Get quote
            path = [
                Web3.to_checksum_address(token_in),
                Web3.to_checksum_address(token_out)
            ]
            
            amounts = router.functions.getAmountsOut(amount_in_wei, path).call()
            amount_out_wei = amounts[1]
            
            # Get output token decimals
            token_out_contract = self.w3.eth.contract(
                address=Web3.to_checksum_address(token_out),
                abi=ERC20_ABI
            )
            out_decimals = token_out_contract.functions.decimals().call()
            
            amount_out = Decimal(amount_out_wei) / Decimal(10 ** out_decimals)
            price = amount_out / amount_in
            
            return PriceQuote(
                dex_name=dex_name,
                token_in=token_in,
                token_out=token_out,
                amount_in=amount_in,
                amount_out=amount_out,
                price=price
            )
            
        except Exception as e:
            logger.debug(f"Failed to get quote from {dex_name}: {e}")
            return None
    
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    # ARBITRAGE DETECTION
    # â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    def find_arbitrage_routes(
        self,
        start_token: str,
        amount: Decimal
    ) -> List[ArbitrageRoute]:
        """Find profitable arbitrage routes"""
        routes = []
        
        # Get common tokens to check
        tokens = [
            self.chain_config['weth'],
            self.chain_config['usdc'],
            self.chain_config['usdt'],
            self.chain_config['dai']
        ]
        
        # Try different 3-leg routes
        for intermediate1 in tokens:
            if intermediate1 == start_token:
                continue
                
            for intermediate2 in tokens:
                if intermediate2 == start_token or intermediate2 == intermediate1:
                    continue
                
                # Build 3-leg route
                route = self._build_route(
                    start_token,
                    [intermediate1, intermediate2, start_token],
                    amount
                )
                
                if route and route.net_profit > self.min_profit_usd:
                    routes.append(route)
        
        # Sort by net profit
        routes.sort(key=lambda x: x.net_profit, reverse=True)
